#!/usr/bin/env python3
"""
Robot de Trading Harmonique Automatique
Bas√© sur la strat√©gie des patterns harmoniques avec notifications Telegram
"""

import asyncio
import schedule
import time
from datetime import datetime, timedelta
import pandas as pd
from typing import Dict, List

from config import Config
from utils.logger import TradingLogger
from utils.telegram_notifier import TelegramNotifier
from patterns.harmonic_detector import HarmonicPatternDetector
from patterns.zone_manager import ZoneManager
from trading.confirmation_system import ConfirmationSystem
from trading.connector_factory import ConnectorFactory
from trading.position_manager import PositionManager

class HarmonicTradingBot:
    def __init__(self):
        self.logger = TradingLogger()
        self.telegram = TelegramNotifier()
        self.pattern_detector = HarmonicPatternDetector()
        self.zone_manager = ZoneManager()
        self.confirmation_system = ConfirmationSystem()
        
        # Connexions trading - utiliser la factory pour le bon connecteur
        self.exchange = ConnectorFactory.create_connector()
        self.position_manager = PositionManager(self.exchange)
        
        # Afficher les informations de la plateforme
        platform_info = ConnectorFactory.get_platform_info()
        self.logger.info(f"Plateforme: {platform_info['platform'].upper()}")
        self.logger.info(f"Type de compte: {platform_info['account_type'].upper()}")
        self.logger.info(f"Symbole par d√©faut: {platform_info['symbol_default']}")
        
        # √âtat du bot
        self.is_running = False
        self.last_analysis_time = None
        self.detected_patterns = {}
        
        self.logger.info("Robot de trading harmonique initialis√©")
    
    async def start(self):
        """D√©marre le robot de trading"""
        try:
            self.is_running = True
            
            # Notification de d√©marrage
            await self.telegram.notify_bot_status(
                "D√âMARRAGE", 
                self.position_manager.get_active_positions_count(),
                self.position_manager.get_daily_pnl()
            )
            
            self.logger.info("üöÄ Robot de trading harmonique d√©marr√©")
            
            # Planifier les t√¢ches
            self._schedule_tasks()
            
            # Boucle principale
            while self.is_running:
                try:
                    # Ex√©cuter les t√¢ches planifi√©es
                    schedule.run_pending()
                    
                    # Surveillance des positions
                    await self.position_manager.monitor_positions()
                    
                    # Attendre avant la prochaine it√©ration
                    await asyncio.sleep(10)  # 10 secondes
                    
                except KeyboardInterrupt:
                    self.logger.info("Arr√™t demand√© par l'utilisateur")
                    break
                except Exception as e:
                    self.logger.error(f"Erreur dans la boucle principale: {e}")
                    await asyncio.sleep(30)  # Attendre plus longtemps en cas d'erreur
            
        except Exception as e:
            self.logger.error(f"Erreur critique au d√©marrage: {e}")
            await self.telegram.notify_error("DEMARRAGE", str(e))
        finally:
            await self.stop()
    
    def _schedule_tasks(self):
        """Planifie les t√¢ches r√©currentes"""
        # Analyse des patterns toutes les 5 minutes
        schedule.every(5).minutes.do(self._run_async_task, self.analyze_market)
        
        # Mise √† jour du solde toutes les heures
        schedule.every().hour.do(self._run_async_task, self.update_account_info)
        
        # Nettoyage quotidien
        schedule.every().day.at("00:00").do(self._run_async_task, self.daily_cleanup)
        
        # Rapport de statut toutes les 4 heures
        schedule.every(4).hours.do(self._run_async_task, self.send_status_report)
    
    def _run_async_task(self, coro):
        """Ex√©cute une coroutine dans la boucle d'√©v√©nements"""
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                asyncio.create_task(coro())
            else:
                loop.run_until_complete(coro())
        except Exception as e:
            self.logger.error(f"Erreur ex√©cution t√¢che async: {e}")
    
    async def analyze_market(self):
        """Analyse compl√®te du march√©"""
        try:
            self.logger.info("üîç D√©but de l'analyse du march√©")
            
            symbol = Config.SYMBOL
            
            # R√©cup√©rer les donn√©es historiques
            df_1h = self.exchange.get_historical_data(symbol, Config.TIMEFRAME_MAIN, 200)
            df_5m = self.exchange.get_historical_data(symbol, Config.TIMEFRAME_ENTRY, 100)
            
            if df_1h.empty or df_5m.empty:
                self.logger.warning("Donn√©es insuffisantes pour l'analyse")
                return
            
            # D√©tecter les patterns harmoniques
            patterns = self.pattern_detector.detect_patterns(df_1h)
            
            for pattern in patterns:
                await self._process_pattern(pattern, df_1h, df_5m)
            
            self.last_analysis_time = datetime.now()
            
            # Notification d'analyse
            await self.telegram.notify_analysis_update(
                symbol, 
                f"{len(patterns)} patterns d√©tect√©s",
                f"Derni√®re analyse: {self.last_analysis_time.strftime('%H:%M:%S')}"
            )
            
        except Exception as e:
            self.logger.error(f"Erreur analyse march√©: {e}")
            await self.telegram.notify_error("ANALYSE_MARCHE", str(e))
    
    async def _process_pattern(self, pattern: Dict, df_1h: pd.DataFrame, df_5m: pd.DataFrame):
        """Traite un pattern d√©tect√©"""
        try:
            pattern_id = f"{pattern['type']}_{pattern['completion_time']}"
            
            # √âviter de retraiter le m√™me pattern
            if pattern_id in self.detected_patterns:
                return
            
            self.logger.info(f"üìä Traitement du pattern {pattern['type']} (confiance: {pattern['confidence']:.1f}%)")
            
            # Cr√©er les zones Fibonacci
            zones = self.zone_manager.create_fibonacci_zones(pattern)
            
            # Notification de pattern d√©tect√©
            await self.telegram.notify_pattern_detected(
                pattern['type'],
                Config.SYMBOL,
                f"D:{pattern['points']['D']['price']:.4f}",
                pattern['confidence']
            )
            
            # V√©rifier les confirmations d'entr√©e
            confirmations = self.confirmation_system.check_entry_confirmations(
                df_1h, df_5m, pattern, zones
            )
            
            # Enregistrer le pattern
            self.detected_patterns[pattern_id] = {
                'pattern': pattern,
                'zones': zones,
                'detection_time': datetime.now(),
                'processed': False
            }
            
            # Si signal d'entr√©e confirm√©
            if confirmations['entry_signal']:
                await self._handle_entry_signal(pattern, zones, confirmations)
            else:
                # Notification de zone d'entr√©e d√©tect√©e (en attente)
                await self.telegram.notify_entry_zone(
                    Config.SYMBOL,
                    f"Zone 0.886: {zones.get('fib_886', 0):.4f}",
                    zones.get('fib_886', 0),
                    'BUY' if pattern['direction'] == 'bullish' else 'SELL'
                )
        
        except Exception as e:
            self.logger.error(f"Erreur traitement pattern: {e}")
    
    async def _handle_entry_signal(self, pattern: Dict, zones: Dict, confirmations: Dict):
        """G√®re un signal d'entr√©e confirm√©"""
        try:
            # V√©rifier les limites de positions
            active_positions = self.position_manager.get_active_positions_count()
            
            if active_positions >= Config.MAX_POSITIONS:
                self.logger.warning(f"Limite de positions atteinte ({Config.MAX_POSITIONS})")
                return
            
            # Ex√©cuter l'entr√©e
            success = await self.position_manager.execute_entry_signal(
                pattern, zones, confirmations
            )
            
            if success:
                self.logger.info("‚úÖ Position ouverte avec succ√®s")
                
                # Marquer le pattern comme trait√©
                pattern_id = f"{pattern['type']}_{pattern['completion_time']}"
                if pattern_id in self.detected_patterns:
                    self.detected_patterns[pattern_id]['processed'] = True
            else:
                self.logger.warning("‚ùå √âchec de l'ouverture de position")
        
        except Exception as e:
            self.logger.error(f"Erreur gestion signal d'entr√©e: {e}")
            await self.telegram.notify_error("SIGNAL_ENTREE", str(e))
    
    async def update_account_info(self):
        """Met √† jour les informations du compte"""
        try:
            self.exchange.update_balance()
            # Adapter selon la plateforme
            currency = 'USD' if Config.TRADING_PLATFORM.lower() == 'mt5' else 'USDT'
            balance = self.exchange.get_available_balance(currency)
            
            self.logger.info(f"üí∞ Solde {currency}: {balance:.2f}")
            
        except Exception as e:
            self.logger.error(f"Erreur mise √† jour compte: {e}")
    
    async def daily_cleanup(self):
        """Nettoyage quotidien"""
        try:
            # Nettoyer les anciennes positions
            self.position_manager.cleanup_old_positions()
            
            # Nettoyer les anciennes zones
            self.zone_manager.cleanup_old_zones()
            
            # Nettoyer les anciens patterns
            self._cleanup_old_patterns()
            
            self.logger.info("üßπ Nettoyage quotidien effectu√©")
            
        except Exception as e:
            self.logger.error(f"Erreur nettoyage quotidien: {e}")
    
    def _cleanup_old_patterns(self, max_age_hours: int = 48):
        """Nettoie les anciens patterns"""
        current_time = datetime.now()
        patterns_to_remove = []
        
        for pattern_id, pattern_data in self.detected_patterns.items():
            age = (current_time - pattern_data['detection_time']).total_seconds() / 3600
            if age > max_age_hours:
                patterns_to_remove.append(pattern_id)
        
        for pattern_id in patterns_to_remove:
            del self.detected_patterns[pattern_id]
    
    async def send_status_report(self):
        """Envoie un rapport de statut"""
        try:
            active_positions = self.position_manager.get_active_positions_count()
            daily_pnl = self.position_manager.get_daily_pnl()
            
            await self.telegram.notify_bot_status(
                "ACTIF" if self.is_running else "INACTIF",
                active_positions,
                daily_pnl
            )
            
        except Exception as e:
            self.logger.error(f"Erreur rapport de statut: {e}")
    
    async def stop(self):
        """Arr√™te le robot de trading"""
        try:
            self.is_running = False
            
            # Fermer toutes les positions si demand√©
            # await self.position_manager.close_all_positions("Arr√™t du robot")
            
            # Notification d'arr√™t
            await self.telegram.notify_bot_status(
                "ARR√äT√â",
                self.position_manager.get_active_positions_count(),
                self.position_manager.get_daily_pnl()
            )
            
            self.logger.info("üõë Robot de trading harmonique arr√™t√©")
            
        except Exception as e:
            self.logger.error(f"Erreur lors de l'arr√™t: {e}")

def main():
    """Point d'entr√©e principal"""
    try:
        # Cr√©er et d√©marrer le bot
        bot = HarmonicTradingBot()
        
        # D√©marrer la boucle d'√©v√©nements
        asyncio.run(bot.start())
        
    except KeyboardInterrupt:
        print("\nüõë Arr√™t du robot demand√© par l'utilisateur")
    except Exception as e:
        print(f"‚ùå Erreur critique: {e}")

if __name__ == "__main__":
    main()
